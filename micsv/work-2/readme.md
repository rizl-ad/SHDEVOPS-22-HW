# Решение ДЗ к занятию «Микросервисы: принципы»

## Задача 1: API Gateway

Сравнительная таблица, в которой представлены ключевые характеристики наиболее популярных on-premises open-source API Gateway решений.

| **Характеристика**                                          | **Kong Gateway**                                                | **Tyk Gateway**                                                      | **KrakenD CE**                                                | **Apache APISIX**                                         | **Gravitee.io CE**                                                 | **WSO2 API Manager**                                            | **Envoy**                                                     | **Traefik**                                              | **NGINX**                                                 |
| ----------------------------------------------------------- | --------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------- | --------------------------------------------------------- | ------------------------------------------------------------------ | --------------------------------------------------------------- | ------------------------------------------------------------- | -------------------------------------------------------- | --------------------------------------------------------- |
| **Масштабируемость**                                        | Высокая, поддержка кластеризации и балансировки нагрузки        | Высокая, поддержка кластеров и масштабирования через мастер/слейв    | Очень высокая, поддержка агрегации множества API              | Очень высокая, поддержка кластеризации и масштабируемости | Высокая, поддержка кластеризации и распределенных систем           | Высокая, поддержка горизонтального масштабирования              | Очень высокая, интеграция с сервисной сеткой (Service Mesh)   | Высокая, интеграция с Docker/Kubernetes                  | Высокая, поддержка кластеризации и балансировки нагрузки  |
| **Производительность**                                      | Высокая, оптимизировано для высоконагруженных API               | Высокая, высокая производительность                                  | Очень высокая, оптимизировано для агрегации                   | Высокая, низкая латентность                               | Хорошая, но ограничена сложностью конфигурации                     | Хорошая, поддержка нагрузки и масштабируемости                  | Очень высокая, оптимизировано для работы с микросервисами     | Высокая, низкая латентность, быстрая маршрутизация       | Очень высокая, отличная производительность на уровне HTTP |
| **Отказоустойчивость**                                      | Высокая, поддержка фейловеров и кластеризации                   | Высокая, встроенная поддержка фейловеров                             | Высокая, поддержка балансировки нагрузки и отказоустойчивости | Высокая, поддержка фейловеров и репликации                | Средняя, зависит от настроек                                       | Очень высокая, поддержка отказоустойчивости и репликации        | Очень высокая, встроенные механизмы фейловеров и балансировки | Высокая, поддержка отказоустойчивости и репликации       | Высокая, поддержка фейловеров, репликации и кластеризации |
| **Маршрутизация**                                  		      | Очень гибкая маршрутизация по URI, HTTP методам, заголовкам     | Гибкая маршрутизация по URI, методам, заголовкам и другим параметрам | Ограниченная гибкость, фокус на агрегации                     | Очень гибкая маршрутизация с поддержкой сложных маршрутов | Средняя гибкость маршрутизации, поддержка кастомизации             | Очень гибкая маршрутизация с поддержкой сложных схем            | Очень гибкая маршрутизация с настройкой через фильтры         | Гибкая маршрутизация с поддержкой динамических маршрутов | Простая маршрутизация, поддержка стандартных маршрутов    |
| **Аутентификация** 					                                | Поддержка JWT, OAuth 2.0, API Keys, HMAC и других               | Поддержка JWT, OAuth 2.0, API Keys, HMAC, LDAP и других              | Поддержка JWT, OAuth 2.0 через плагины                        | Поддержка JWT, OAuth 2.0, Keycloak и других               | Поддержка JWT, OAuth 2.0, API Keys                                 | Поддержка OAuth 2.0, JWT, SSO, LDAP                             | Интеграция с внешними сервисами для аутентификации            | Интеграция с внешними системами для аутентификации       | Ограниченные возможности через модули                     |
| **Авторизация**                                             | Поддержка RBAC, ACL, плагинов                                   | Поддержка RBAC, ACL, плагинов                                        | Поддержка RBAC, ACL через плагины                             | Поддержка RBAC, ACL через плагины                         | Поддержка RBAC, ACL                                                | Расширенная авторизация через WSO2 Identity Server              | Интеграция с внешними системами для авторизации               | Интеграция с внешними сервисами для авторизации          | Ограниченные возможности через модули                     |
| **Мониторинг и логирование**                                | Интеграция с Prometheus, Grafana, ELK Stack                     | Встроенные средства аналитики, поддержка Prometheus, Grafana         | Интеграция с Prometheus                                       | Интеграция с Prometheus, Grafana, ELK                     | Встроенные возможности мониторинга, поддержка внешних инструментов | Встроенные средства мониторинга, поддержка внешних инструментов | Интеграция с Prometheus, Datadog и другими системами          | Интеграция с Prometheus и другими системами              | Интеграция с Prometheus, ELK и другими внешними системами |
| **Управление трафиком**                                     | Поддержка rate limiting, circuit breaking, retries, IP blocking | Поддержка rate limiting, retries, IP blocking, backpressure          | Поддержка rate limiting, retries, circuit breaking            | Поддержка rate limiting, retries, circuit breaking        | Поддержка rate limiting, retries, circuit breaking                 | Поддержка rate limiting, retries, circuit breaking              | Поддержка rate limiting, retries, circuit breaking            | Поддержка rate limiting, retries, circuit breaking       | Поддержка rate limiting, retries, circuit breaking        |
| **Кэширование**                                             | Встроенное кэширование запросов и ответов                       | Кэширование на уровне запросов и ответов                             | Поддержка кэширования ответов API                             | Встроенные возможности кэширования                        | Встроенные возможности кэширования                                 | Встроенное кэширование, возможности настройки                   | Встроенное кэширование через фильтры                          | Встроенные возможности кэширования                       | Встроенное кэширование на уровне HTTP                     |
| **Поддержка контейнеризации**                               | Да, поддержка Docker, Kubernetes                                | Да, поддержка Docker, Kubernetes                                     | Да, поддержка Docker, Kubernetes                              | Да, поддержка Docker, Kubernetes                          | Да, поддержка Docker, Kubernetes                                   | Да, поддержка Docker, Kubernetes                                | Да, интеграция с сервисной сеткой                             | Да, интеграция с Docker, Kubernetes                      | Да, поддержка Docker, Kubernetes                          |
| **Терминация HTTPS**                                        | Поддержка терминации HTTPS, настройка SSL                       | Поддержка терминации HTTPS, настройка сертификатов через UI          | Поддержка терминации HTTPS через конфигурацию                 | Поддержка терминации HTTPS через конфигурацию             | Поддержка терминации HTTPS                                         | Поддержка терминации HTTPS через конфигурацию                   | Поддержка терминации HTTPS и конфигурирования SSL/TLS         | Поддержка терминации HTTPS через Let's Encrypt           | Поддержка терминации HTTPS через конфигурационные файлы   |


### Рекомендации:
Kong Gateway и Tyk Gateway — лучшие выборы для крупных компаний, оба решения обеспечивают гибкую маршрутизацию, проверку аутентификационной информации (JWT, OAuth 2.0), терминацию HTTPS и масштабируемость. Эти решения также поддерживают расширение через плагины, что делает их отличными для сложных микросервисных архитектур.

**Tyk Gateway** является отличным выбором, и в некоторых случаях он может быть предпочтительнее **Kong Gateway**, в зависимости от специфики требований. Выбо сделан в пользу **Kong** по следующим причинам:

### 1. **Широкий функционал из коробки и экосистема**
- **Kong** предлагает более широкий набор функционала и более развитую экосистему с множеством плагинов и интеграций, как для мониторинга, так и для безопасности (например, интеграция с OAuth 2.0, JWT, API Keys, и многое другое). Это дает больше гибкости и возможностей для кастомизации.
- **Tyk** тоже поддерживает эти функции, но в **Kong** можно найти более зрелое и проверенное решение с широким набором плагинов, особенно когда речь идет о мониторинге, логировании и интеграциях с такими популярными инструментами, как Prometheus и Grafana.

### 2. **Масштабируемость и производительность**
- **Kong** имеет высокую производительность и эффективную архитектуру для горизонтального масштабирования. Он использует распределённую базу данных (например, Cassandra или PostgreSQL) для хранения данных, что позволяет ему масштабироваться в больших системах.
- **Tyk** также поддерживает масштабируемость, но архитектура в **Kong** была специально оптимизирована для работы в крупных распределённых системах, где важна высокая доступность и отказоустойчивость при масштабировании.

### 3. **Решения для микросервисов и сервисных сеток**
- **Kong** активно интегрируется с сервисными сетями и Service Mesh (например, Istio, Consul), что делает его отличным выбором для сложных микросервисных архитектур с потребностью в гибкой маршрутизации и управлении трафиком.
- **Tyk** тоже поддерживает интеграции с такими сервисами, но по функционалу **Kong** в этом контексте более зрелый и предлагает больше возможностей для интеграции с **Service Mesh**.

### 4. **Поддержка контейнеризации и Kubernetes**
- **Kong** имеет активную интеграцию с **Kubernetes** и **Docker**, что делает его отличным выбором для микросервисов в контейнеризованных средах. В отличии от **Tyk**, **Kong** может предложить более удобные и гибкие механизмы развертывания в таких средах.

### 5. **Сообщество и коммерческая поддержка**
- **Kong** имеет более крупное и активное сообщество, а также предлагает разнообразные коммерческие версии с расширенным функционалом и поддержкой. Это может быть полезно, если вам нужно больше возможностей или гарантии поддержки на уровне предприятия.
- **Tyk** тоже имеет активное сообщество и предлагает как бесплатные, так и платные версии. Однако, если для компании важна активная поддержка и множество плагинов, **Kong** может предложить больше вариантов.

### 6. **Цены и лицензирование**
- **Tyk** имеет более простую и гибкую лицензию, и в некоторых случаях это может быть выгодно для компаний с ограниченным бюджетом. Он предоставляет бесплатную и коммерческую версии, и стоимость лицензии на платные функции (например, управление API) может быть ниже, чем у **Kong**.
- **Kong** может быть дороже в плане коммерческих лицензий, но в этом случае вы получаете более широкий функционал и более зрелое решение для масштабных инфраструктур.

### 7. **Модульность**
- **Kong** поддерживает много сторонних плагинов и расширений, что делает его более гибким и настраиваемым для различных нужд. Например, можно использовать плагины для медленного старта, профилирования и оптимизации запросов.
- В **Tyk** тоже есть плагины, но их экосистема не так масштабна, и для некоторых специализированных случаев может не хватить гибкости.

### Заключение:

Если компания разрабатывает крупную распределённую систему с высоким уровнем сложности, с требованиями к масштабируемости, гибкости маршрутизации, интеграции с Service Mesh и обширным мониторингом, то **Kong** будет лучшим выбором. **Kong** предоставляет больше возможностей, инструментов и гибкости, что делает его предпочтительным для более сложных архитектур.

## Задача 2: Брокер сообщений

Сравнение по ключевым параметрам различных open-source брокеров сообщений:

| Брокер              | Протоколы            | Производительность | Масштабируемость | Простота настройки | Описание использования                      |
| ------------------- | -------------------- | ------------------ | ---------------- | ------------------ | ------------------------------------------- |
| **Apache Kafka**    | Kafka, Avro          | Высокая            | Отличная         | Средняя            | Потоковая обработка данных, аналитика.      |
| **RabbitMQ**        | AMQP, MQTT, STOMP    | Средняя            | Хорошая          | Легкая             | Очереди сообщений, асинхронная обработка.   |
| **ActiveMQ**        | AMQP, MQTT, OpenWire | Средняя            | Хорошая          | Средняя            | Корпоративные системы, интеграции.          |
| **NATS**            | NATS                 | Высокая            | Хорошая          | Очень легкая       | Микросервисы, приложения реального времени. |
| **Mosquitto**       | MQTT                 | Низкая             | Средняя          | Очень легкая       | IoT-приложения, устройства.                 |
| **Redis (Streams)** | Redis                | Очень высокая      | Средняя          | Очень легкая       | Очереди сообщений, кэширование.             |
| **Apache Pulsar**   | Pulsar, Kafka API    | Высокая            | Отличная         | Средняя            | Потоковая обработка данных, стриминг.       |
| **ZeroMQ**          | Приватные протоколы  | Очень высокая      | Ограниченная     | Средняя            | Системы с минимальной задержкой.            |
| **KubeMQ**          | MQTT, HTTP, GRPC     | Высокая            | Отличная (K8s)   | Легкая             | Микросервисы в Kubernetes.                  |
| **Redpanda**        | Kafka                | Очень высокая      | Отличная         | Легкая             | Совместимость с Kafka, потоковые данные.    |

Для крупной компании, строящей систему на основе микросервисной архитектуры, с учётом всех перечисленных требований, оптимальным выбором будет **Apache Kafka**. Это решение соответствует всем критериям по следующим причинам:

### 1. **Поддержка кластеризации для обеспечения надёжности**
- **Apache Kafka** обладает встроенной поддержкой кластеризации. Kafka — это распределённая система, которая позволяет создавать кластеры из нескольких брокеров. Это обеспечивает высокую доступность, отказоустойчивость и автоматическую репликацию данных. В случае сбоя одного из брокеров, система продолжит работать благодаря реплицированным данным на других брокерах.
- **Преимущества**: Легко масштабируемая архитектура, возможность создавать отказоустойчивые кластеры с настройкой репликации на уровне топиков и партиций.

### 2. **Хранение сообщений на диске в процессе доставки**
- Kafka — это не просто брокер сообщений, но и система, которая сохраняет сообщения на диске. Все сообщения, опубликованные в Kafka, сохраняются в журналах (логах), что позволяет хранить их на протяжении определённого времени или до достижения заданного размера.
- **Преимущества**: Возможность долговременного хранения сообщений (параметризуемое время хранения или размер) без потери данных. Это позволяет Kafka работать как брокер с гарантированным сохранением сообщений, что важно для аудита, обработки событий и репликации данных.

### 3. **Высокая скорость работы**
- **Apache Kafka** спроектирован для работы с большими объёмами данных в реальном времени, и его производительность одна из лучших среди брокеров сообщений. Kafka использует эффективную модель записи данных (append-only log) и поддерживает параллельную обработку сообщений через разделение на партиции.
- **Преимущества**: Очень высокая пропускная способность — Kafka способен обрабатывать миллионы сообщений в секунду, что важно для крупных распределённых систем с высокой нагрузкой.

### 4. **Поддержка различных форматов сообщений**
- Kafka поддерживает любые бинарные и текстовые форматы сообщений, поскольку сообщения передаются в виде байтовых массивов. Это позволяет использовать произвольные сериализаторы/десериализаторы данных (например, Avro, JSON, Protobuf и другие).
- **Преимущества**: Гибкость в выборе форматов сообщений, возможность использовать схемы данных (например, Avro), что упрощает интеграцию с другими системами и предотвращает проблемы с несовместимостью форматов.

### 5. **Разделение прав доступа к различным потокам сообщений**
- Kafka предоставляет встроенные механизмы для управления правами доступа с помощью ACL (Access Control Lists). Эти механизмы позволяют разграничивать доступ к различным топикам, и правами на чтение/запись можно управлять для каждого пользователя или приложения.
- **Преимущества**: Возможность настройки детализированных прав доступа для разных потоков сообщений (топиков и партиций). Это важно для корпоративных приложений, где требуется разграничение доступа для различных команд и сервисов.

### 6. **Простота эксплуатации**
- Kafka имеет хорошо документированное и развивающееся сообщество, а также множество инструментов для мониторинга, управления и настройки. Kafka поддерживает такие средства как Confluent Control Center, Kafka Manager, а также интеграцию с Prometheus для мониторинга. Также существуют автоматизированные решения для настройки и обслуживания, например, Kubernetes-решения для деплоя.
- **Преимущества**: Несмотря на свою мощность, Kafka предоставляет удобные инструменты для настройки и эксплуатации. Интеграция с популярными инструментами мониторинга и управления также делает эксплуатацию проще.

Таким образом, **Apache Kafka** полностью соответствует всем требованиям для построения крупной, масштабируемой и надёжной системы на основе микросервисной архитектуры.

## Задача 3: API Gateway

Для запуска исходников потребовалось сделать адаптацию под актуальные версии ПО:
1. изменить версии зависимостей сервиса secutity:
- Flask>=2.3
- prometheus-flask-exporter==0.23.2
2. в docker-compose.yml адаптировать команды под актуальную версию minio.

По заданию необходимо маршрутизировать запросы `POST /v1/register` и `GET /v1/user`, но для них не описаны эндпоинты в сервисе security (в файле server.py).

Добавил в server.py эндпоинт для `POST /v1/register` - как я понял, это должна быть регистрация нового пользователя, сделал через анонимный доступ, как описан запрос в задании, хотя секурнее сделать с авторизацией.

`GET /v1/user` не стал добавлять - не очень понял какое действие под ним подразумевается.

Изменил вывод токена и имени файла - теперь вывод с переносом строки, чтобы в терминале вывод не сливался с приглашением командной строки

[nginx.conf](https://github.com/rizl-ad/SHDEVOPS-22-HW/blob/main/micsv/work-2/task3/gateway/nginx.conf)

[Итоговый проект](https://github.com/rizl-ad/SHDEVOPS-22-HW/tree/main/micsv/work-2/task3)

Скрин выполнения команд:

<img width="790" height="138" alt="t3_1" src="https://github.com/user-attachments/assets/ebaba085-72f7-4a86-b6d0-ab04bcee7df8" />

